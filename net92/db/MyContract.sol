pragma solidity ^0.8.0;contract DynamicPriceOracle {    uint public acceptableDelay;    uint public lastUpdateTimestamp;    uint public currentPrice;    address public admin;    mapping(address => bool) public authorizedUpdaters;    event NewAcceptableDelay(uint oldDelay, uint newDelay);    event PriceUpdated(uint oldPrice, uint newPrice, uint timestamp);    event UpdaterStatusChanged(address updater, bool isAuthorized);    modifier onlyAdmin() {        require(msg.sender == admin, 'DynamicPriceOracle: caller is not admin');        _;    }    modifier onlyAuthorized() {        require(authorizedUpdaters[msg.sender] || msg.sender == admin, 'DynamicPriceOracle: not authorized');        _;    }    constructor(uint initialPrice, uint initialDelay) {        admin = msg.sender;        currentPrice = initialPrice;        lastUpdateTimestamp = block.timestamp;        _configureAcceptableDelay(initialDelay);    }    function _configureAcceptableDelay(uint _acceptableDelay) private {        emit NewAcceptableDelay(acceptableDelay, _acceptableDelay);        require(_acceptableDelay > 0, 'PriceOracle: zero amount');        acceptableDelay = _acceptableDelay;    }    function updateAcceptableDelay(uint _newDelay) external onlyAdmin {        _configureAcceptableDelay(_newDelay);    }    function updatePrice(uint _newPrice) external onlyAuthorized {        require(block.timestamp >= lastUpdateTimestamp + acceptableDelay, 'DynamicPriceOracle: update too soon');        emit PriceUpdated(currentPrice, _newPrice, block.timestamp);        currentPrice = _newPrice;        lastUpdateTimestamp = block.timestamp;    }    function setUpdaterStatus(address updater, bool isAuthorized) external onlyAdmin {        authorizedUpdaters[updater] = isAuthorized;        emit UpdaterStatusChanged(updater, isAuthorized);    }    function getPriceWithVerification() external view returns (uint price, bool isFresh) {        bool isRecent = (block.timestamp - lastUpdateTimestamp) <= acceptableDelay * 2;        return (currentPrice, isRecent);    }}